---
title: "Cell type annotation and topic modelling"
date: "`r Sys.Date()`"
bibliography: "reference.bib"
---


```{r GlobOpt, include = FALSE}
################################################################
fig.dir = 'Fig/STEP2/'
dir.create(fig.dir, recursive = TRUE, showWarnings = FALSE)
knitr::opts_knit$set(eval.after = 'fig.cap')
knitr::opts_chunk$set(warning = FALSE, message = FALSE, fig.path = fig.dir)
knitr::opts_chunk$set(fig.width=8, fig.height=8)
options(stringsAsFactors = FALSE)
FIG.CAP = '**Fig.**'
library(data.table)
library(dplyr)
library(patchwork)
library(mmutilR)
source("Util-rmd.R")
.fread <- function(...) fread(..., header=FALSE)
.fwrite <- function(...) fwrite(..., quote=FALSE, sep="\t", row.names = FALSE, col.names = FALSE)
```

```{r include=FALSE}
plt.scatter.ct.2 <- function(.ct.show, .assign.tab, .mtx,
                             m1x = "CD25",
                             m1y = "CD127",
                             m2x = "CD45RO",
                             m2y = "CD45RA") {

    .idx <- data.table(tag = colnames(.mtx)) %>%
        mutate(j = 1:n()) %>% 
        left_join(.assign.tab[as.character(celltype) %in% .ct.show]) %>%
        select(j, celltype, prob)

    .dt <- data.table(m1x = .mtx["anti_" %&% m1x, .idx$j],
                      m1y = .mtx["anti_" %&% m1y, .idx$j],
                      m2x = .mtx["anti_" %&% m2x, .idx$j],
                      m2y = .mtx["anti_" %&% m2y, .idx$j],
                      prob = .idx$prob,
                      celltype = factor(.idx$celltype, .ct.show))
    .dt <- .dt[celltype %in% .ct.show]
    .med.dt <-
        .dt[m1x > 0 &
            m2x > 0 &
            m1y > 0 &
            m2y > 0,
            .(m1x = median(m1x),
                m1y = median(m1y),
                m2x = median(m2x),
                m2y = median(m2y)),
            by = .(celltype)]

    .add.lab <- function(.plt) {

        .lab <- function(x) num.int(10^x)
        .brk <- seq(0,5)

        .plt +
            theme_classic() +
            theme(axis.text = element_text(size=6)) +
            scale_x_continuous(breaks=.brk, labels=.lab) +
            scale_y_continuous(breaks=.brk, labels=.lab) +
            theme(axis.text.x = element_text(angle=90, vjust=1, hjust=1)) +
            facet_grid(.~celltype) +
            stat_density_2d(geom = "raster",
                            aes(fill = after_stat(density)),
                            show.legend=F,
                            contour=F) +
            scale_fill_viridis_c() +
            stat_density2d(linewidth=.2, colour="white") +
            geom_point(data=.med.dt, colour=2, pch=3, size=2, stroke=2) +
            geom_abline(slope=1, size=.1, colour="white")
    }
    .aes <- aes(x=log10(m1x), y=log10(m1y))
    p1 <- (ggplot(.dt[m1x > 0 & m1y > 0], .aes) %>% .add.lab) +
        xlab(m1x) + ylab(m1y)
    .aes <- aes(x=log10(m2x), y=log10(m2y))
    p2 <- (ggplot(.dt[m2x > 0 & m2y > 0], .aes) %>% .add.lab) +
        xlab(m2x) + ylab(m2y)
    p1/p2
}
```

# Round 1: Top-level cell type annotation

## Can we distinguish cell types by surface proteins?

* nTconv : CD3+, CD4+, CD8-, CD25-/CD127+, CD45RA+/CD45RO-
* mTconv : CD3+, CD4+, CD8-, CD25-/CD127+, CD45RA-/CD45RO+
* nTreg : CD3+, CD4+, CD8-, CD25+/CD127-, CD45RA+/CD45RO-
* mTreg : CD3+, CD4+, CD8-, CD25+/CD127-, CD45RA-/CD45RO+

Run annotation purely based on marker genes:

```{r}
.read.marker.file <- function(.file){
    x <- .fread(.file, col.names=c("feat","ct"))
    .xx <- x[, .(feat=list(feat)), by = .(ct)];
    .ret <- .xx$feat; names(.ret) <- .xx$ct;
    .ret
}
```

```{r select_proteins_only}
.hdr <- "result/step1/matrix_final"
.data <- fileset.list(.hdr)

.proteins <-
    .fread(.data$row, col.names="feat") %>%
    filter(str_starts(feat, "anti_")) %>%
    unlist()
  
.prot.hdr <- "result/step2/prot"
.prot.data <- fileset.list(.prot.hdr)

if.needed(.prot.data, {
    .prot.data <-
        rcpp_mmutil_copy_selected_rows(.data$mtx,
                                       .data$row,
                                       .data$col,
                                       .proteins,
                                       .prot.hdr)
})
```


```{r run_bbknn_protein_data}
.batches <- .fread(.prot.data$col, col.names="tag")
.batches[, c("barcode","batch") := tstrsplit(tag, "_")]

.bbknn <- rcpp_mmutil_bbknn_pca(.prot.data$mtx,
                                .batches$batch,
                                knn = 100, RANK = 15,
                                EM_ITER = 20,
                                TAKE_LN = TRUE)

```


```{r}

.pos.markers <- .read.marker.file("marker/surface_round1_positive.txt")
.neg.markers <- .read.marker.file("marker/surface_round1_negative.txt")

    .annot.out <-
        rcpp_mmutil_annotate_columns(
            pos_labels = list(p1=.pos.markers),
            r_neg_labels = list(n1=.neg.markers),
            row_file = .prot.data$row,
            col_file = .prot.data$col,
            r_U = .bbknn$U,
            r_D = .bbknn$D,
            r_V = .bbknn$factors.adjusted,
            EM_TOL = 1e-6,
            EM_ITER = 500)

annot.dt <- setDT(.annot.out$annotation)

.col <- c("tag", "celltype", "prob", "ln.prob")
names(annot.dt) <- .col
annot.dt[, c("barcode","batch") := tstrsplit(tag, split="_")]
```


```{r}

U <- .bbknn$U
D <- .bbknn$D
V <- .bbknn$factors.adjusted

prot.mtx <- pmax(exp(sweep(U, 2, D, `*`) %*% t(V)) - 1, 0)
prot.mtx <- apply(prot.mtx, 2, function(x) x/pmax(sum(x),1) * 1e4)

rownames(prot.mtx) <- readLines(.prot.data$row)
colnames(prot.mtx) <- readLines(.prot.data$col)

.ct <- c("mTreg","nTreg","mTconv","nTconv")
plt <- plt.scatter.ct.2(.ct, annot.dt, prot.mtx)
print(plt)

```


```{r}

prot.raw.mtx <- read.dense(.prot.data$mtx)
rownames(prot.raw.mtx) <- readLines(.prot.data$row)
colnames(prot.raw.mtx) <- readLines(.prot.data$col)

.ct <- c("mTreg","nTreg","mTconv","nTconv")
plt <- plt.scatter.ct.2(.ct, annot.dt, prot.raw.mtx)
print(plt)

```

TODO


## Non-negative matrix factorization of the protein expressions

```{r}

.cells <- fread(.prot.data$col, header=F)
.cells[, c("barcode","batch") := tstrsplit(`V1`,split="_"), ]

.bulk <- asapR::asap_random_bulk_data(.prot.data$mtx, .prot.data$row,
                                      .prot.data$col, .prot.data$idx,
                                      r_batch = .cells$batch,
                                      num_factors = 5,
                                      NUM_THREADS = 16,
                                      verbose = TRUE)


```






## Non-negative matrix factorization on 

```{r}
.data <- fileset.list("result/step1/matrix_final")
.genes <-
    .fread(.data$row, col.names="feat") %>%
    filter(!str_starts(feat, "anti_")) %>% 
    filter(!str_starts(feat, "MT-")) %>%
    unlist()
.rna.hdr <- "result/step2/rna"
.mkdir(dirname(.rna.hdr))
.rna.data <- mmutilR::fileset.list(.rna.hdr)

if.needed(.rna.data, {
    .rna.data <-
        rcpp_mmutil_copy_selected_rows(.data$mtx,
                                       .data$row,
                                       .data$col,
                                       .genes,
                                       .rna.hdr)
})
```



```{r}
library(asapR)
.cells <- fread(.data$col, header=F)
.cells[, c("barcode","batch") := tstrsplit(`V1`,split="_"), ]

.bulk <- asapR::asap_random_bulk_data(.data$mtx, .data$row,
                                      .data$col, .data$idx,
                                      num_factors = 10,
                                      NUM_THREADS = 16,
                                      do_down_sample = TRUE,
                                      verbose = TRUE)

Y <- stretch_matrix_columns(.bulk$PB)

.nmf <- asapR::asap_fit_nmf(Y,
                            maxK = 12,
                            a0 = 1, b0 = 1,
                            max_iter = 500,
                            svd_init = TRUE,
                            NUM_THREADS = 16)

.stat <- asapR::asap_topic_stat(.rna.data$mtx, .rna.data$row,
                                .rna.data$col, .rna.data$idx,
                                log_x = .nmf$std_log_x,
                                x_row_names = .bulk$rownames,
                                verbose = TRUE)

.corr.vec <- lapply(3:7, function(b) {
    apply(.stat$corr[.cells$batch == b, , drop = F], 2, scale)
})

.bbknn <- asapR::asap_adjust_corr_bbknn(.corr.vec, NUM_THREADS=16)

## TODO: You need to run PCA on the correlation matrix

X <- .bbknn$adjusted

.tsne <- Rtsne::Rtsne(X, num_threads = 16, verbose = TRUE)

.dt <- cbind(data.table(.tsne$Y), annot.dt)

ggplot(.dt[celltype != "CD8"], aes(V1, V2, color=celltype)) +
    geom_point(stroke = 0) +
    scale_color_brewer(palette = "Paired")



## .umap <- uwot::umap(.stat$corr, n_threads=16, min_dist=0, spread=3)
## .dt <- cbind(data.table(.umap), annot.dt)



```






```{r}
ggplot(.dt[sample(.dt], aes(V1, V2, color=batch)) +
    geom_point(stroke = 0) +
    scale_color_brewer(palette = "Spectral")

```




```{r}



.umap <- uwot::umap(.pmf$log.theta, fast_sgd=T, n_threads=16)

.dt <- cbind(data.table(.umap), annot.dt)

ggplot(.dt[celltype != "CD8"], aes(V1, V2, color=celltype)) +
    geom_point(stroke = 0) +
    scale_color_brewer(palette = "Paired")




```
